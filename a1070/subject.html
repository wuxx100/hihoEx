<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1070</p>p#1070 : RMQ问题再临</p><p> input: </p><dd>
<pre>10
618 5122 1923 8934 2518 6024 5406 1020 8291 2647 
6
0 3 6
1 2 2009
0 2 2
0 2 10
1 1 5284
0 2 5</pre>
</dd><p> output: </p><dd>
<pre>1923
2009
1020
1923</pre>
</dd><p>终于，小Hi和小Ho踏上了回国的旅程。在飞机上，望着采购来的特产——小Hi陷入了沉思：还记得在上上周他们去超市的时候，前前后后挑了那么多的东西，都幸运的没有任何其他人（售货员/其他顾客）来打搅他们的采购过程。但是如果发生了这样的事情，他们的采购又会变得如何呢？</p><p>于是小Hi便向小Ho提出了这个问题：假设整个货架上从左到右摆放了N种商品，并且依次标号为1到N，每次小Hi都给出一段区间[L, R]，小Ho要做的是选出标号在这个区间内的所有商品重量最轻的一种，并且告诉小Hi这个商品的重量。但是在这个过程中，可能会因为其他人的各种行为，对某些位置上的商品的重量产生改变（如更换了其他种类的商品），面对这样一个问题，小Ho又该如何解决呢？</p><p><a data-target="#myModal" data-toggle="modal" href="#">提示：平衡乃和谐之理</a></p><p>“这个……数据量，所以这一周又是自由发挥时间了么？”小Ho吐槽道——毕竟这么小的数据量即使使用极为朴素的方法也是可以通过的。</p><p>“差不多吧……不过你倒是发挥一个啊？”小Hi道。</p><p>“这个简单啊，我就对于一个询问，用O(N)的时间进行计算——扫描一遍整个区间找到最小值，然后对于每一个更改操作，使用O(1)的时间直接进行修改，这样也就是O(NQ)的总时间复杂度！在这种数据量下完全是可以通过的！”小Ho想也没有想的就说道。</p><p>“那你还有没有别的想法呢？”小Hi接着问道。</p><p>小Ho低头想了想，继续说道：“那就在ST算法的基础上修改咯，每次询问还是O(1)的时间复杂度，不过每次修改的时候，因为pre_calc数组里面大概有2N个（1+2+4+...）区间包含到了这个位置，所以这O(N)项都要重新进行计算，也就是修改是O(N)的复杂度咯？不过总的来说还是一个O(NQ)的算法呢！”</p><p>“那你知道为什么这两个算法都是这样一个略高（虽然能通过）的复杂度么？”小Hi继续问道。</p><p>“知道啊！就是不够平衡呗，修改和查询这两种操作总是有一个要O(N)，但是另外一个就只要O(1)，如果能够平衡一下这两种操作，就能够解决这个问题了！另外之前我不就说过了线段树可以解决这个问题的么~”小Ho一副自豪的表情。</p><p>“既然你知道，那我可就要问问你了，能够对于区间上修改和查询一类问题进行时间复杂度平衡的除了线段树之外还有什么呢？”小Hi也是要考究考究小Ho。</p><p>“额……这个，都有些啥？”小Ho问道。</p><p>“这个嘛……且听我慢慢道来~！”</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>每组测试数据的第1行为一个整数N，意义如前文所述。</p><p>每组测试数据的第2行为N个整数，分别描述每种商品的重量，其中第i个整数表示标号为i的商品的重量weight_i。</p><p>每组测试数据的第3行为一个整数Q，表示小Hi总共询问的次数与商品的重量被更改的次数之和。</p><p>每组测试数据的第N+4~N+Q+3行，每行分别描述一次操作，每行的开头均为一个属于0或1的数字，分别表示该行描述一个询问和描述一次商品的重量的更改两种情况。对于第N+i+3行，如果该行描述一个询问，则接下来为两个整数Li, Ri，表示小Hi询问的一个区间[Li, Ri]；如果该行描述一次商品的重量的更改，则接下来为两个整数Pi，Wi，表示位置编号为Pi的商品的重量变更为Wi</p><p>对于100%的数据，满足N&lt;=10^4，Q&lt;=10^4, 1&lt;=Li&lt;=Ri&lt;=N，1&lt;=Pi&lt;=N, 0&amp;ltweight_i, Wi&lt;=10^4。</p><p>对于每组测试数据，对于每个小Hi的询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：标号在区间[Li, Ri]中的所有商品中重量最轻的商品的重量。</p><p>终于，小Hi和小Ho踏上了回国的旅程。在飞机上，望着采购来的特产——小Hi陷入了沉思：还记得在上上周他们去超市的时候，前前后后挑了那么多的东西，都幸运的没有任何其他人（售货员/其他顾客）来打搅他们的采购过程。但是如果发生了这样的事情，他们的采购又会变得如何呢？</p><p>于是小Hi便向小Ho提出了这个问题：假设整个货架上从左到右摆放了N种商品，并且依次标号为1到N，每次小Hi都给出一段区间[L, R]，小Ho要做的是选出标号在这个区间内的所有商品重量最轻的一种，并且告诉小Hi这个商品的重量。但是在这个过程中，可能会因为其他人的各种行为，对某些位置上的商品的重量产生改变（如更换了其他种类的商品），面对这样一个问题，小Ho又该如何解决呢？</p><p><a data-target="#myModal" data-toggle="modal" href="#">提示：平衡乃和谐之理</a></p><p>“这个……数据量，所以这一周又是自由发挥时间了么？”小Ho吐槽道——毕竟这么小的数据量即使使用极为朴素的方法也是可以通过的。</p><p>“差不多吧……不过你倒是发挥一个啊？”小Hi道。</p><p>“这个简单啊，我就对于一个询问，用O(N)的时间进行计算——扫描一遍整个区间找到最小值，然后对于每一个更改操作，使用O(1)的时间直接进行修改，这样也就是O(NQ)的总时间复杂度！在这种数据量下完全是可以通过的！”小Ho想也没有想的就说道。</p><p>“那你还有没有别的想法呢？”小Hi接着问道。</p><p>小Ho低头想了想，继续说道：“那就在ST算法的基础上修改咯，每次询问还是O(1)的时间复杂度，不过每次修改的时候，因为pre_calc数组里面大概有2N个（1+2+4+...）区间包含到了这个位置，所以这O(N)项都要重新进行计算，也就是修改是O(N)的复杂度咯？不过总的来说还是一个O(NQ)的算法呢！”</p><p>“那你知道为什么这两个算法都是这样一个略高（虽然能通过）的复杂度么？”小Hi继续问道。</p><p>“知道啊！就是不够平衡呗，修改和查询这两种操作总是有一个要O(N)，但是另外一个就只要O(1)，如果能够平衡一下这两种操作，就能够解决这个问题了！另外之前我不就说过了线段树可以解决这个问题的么~”小Ho一副自豪的表情。</p><p>“既然你知道，那我可就要问问你了，能够对于区间上修改和查询一类问题进行时间复杂度平衡的除了线段树之外还有什么呢？”小Hi也是要考究考究小Ho。</p><p>“额……这个，都有些啥？”小Ho问道。</p><p>“这个嘛……且听我慢慢道来~！”</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>每组测试数据的第1行为一个整数N，意义如前文所述。</p><p>每组测试数据的第2行为N个整数，分别描述每种商品的重量，其中第i个整数表示标号为i的商品的重量weight_i。</p><p>每组测试数据的第3行为一个整数Q，表示小Hi总共询问的次数与商品的重量被更改的次数之和。</p><p>每组测试数据的第N+4~N+Q+3行，每行分别描述一次操作，每行的开头均为一个属于0或1的数字，分别表示该行描述一个询问和描述一次商品的重量的更改两种情况。对于第N+i+3行，如果该行描述一个询问，则接下来为两个整数Li, Ri，表示小Hi询问的一个区间[Li, Ri]；如果该行描述一次商品的重量的更改，则接下来为两个整数Pi，Wi，表示位置编号为Pi的商品的重量变更为Wi</p><p>对于100%的数据，满足N&lt;=10^4，Q&lt;=10^4, 1&lt;=Li&lt;=Ri&lt;=N，1&lt;=Pi&lt;=N, 0&amp;ltweight_i, Wi&lt;=10^4。</p><p>对于每组测试数据，对于每个小Hi的询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：标号在区间[Li, Ri]中的所有商品中重量最轻的商品的重量。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>