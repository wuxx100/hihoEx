<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1089</p>p#1089 : 最短路径·二：Floyd算法</p><p> input: </p><dd>
<pre>5 12
1 2 967
2 3 900
3 4 771
4 5 196
2 4 788
3 1 637
1 4 883
2 4 82
5 2 647
1 4 198
2 4 181
5 2 665</pre>
</dd><p> output: </p><dd>
<pre>0 280 637 198 394 
280 0 853 82 278 
637 853 0 771 967 
198 82 771 0 196 
394 278 967 196 0 
</pre>
</dd><p>万圣节的中午，小Hi和小Ho在吃过中饭之后，来到了一个新的鬼屋！</p><p>鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，但是并不存在一条两端都是同一个地点的道路。</p><p>由于没有肚子的压迫，小Hi和小Ho决定好好的逛一逛这个鬼屋，逛着逛着，小Hi产生了这样的问题：鬼屋中任意两个地点之间的最短路径是多少呢？</p><p>小Ho道：“你说的很有道理，我只需要从每个节点开始使用Dijstra算法就可以了！”</p><p>小Hi摇摇头道：“解决问题不是关键，学到知识才是关键，而且知识本身也远远没有掌握学习的方法重要！”</p><p>小Ho只得答道：“好的好的，听你说便是了!”</p><p>于是小Hi便开心道：“这次要说的算法叫做Floyd算法，是一种用于求图结构上任意两点间最短距离的算法！”</p><p>小Ho嘀咕道：“你都写标题上了，能不知道么？”</p><p>小Hi强行装作没听到，继续说道：“这个算法的核心之处在于数学归纳法——<strong>MinDistance(i, j)之间最短路径中可以用到的节点是一点点增加的！</strong>”</p><p>“你这话每一个字我都听得懂，但是这句话为什么我听不懂呢……”小Ho无奈道。</p><p>“那我这么说吧，<strong>首先，最开始的时候，MinDistance(i, j)——即从第i个点到第j个点的最短路径的长度，拥有一个限制：这条路径不能经过任何节点。</strong>”小Hi道。</p><p>“<strong>那就是说如果从i个点到第j个点之间没有直接相连的边的话，这个长度就是无穷大咯？</strong>”小Ho总结道：“只需要把输入的边填进MinDistance中即可！”</p><p>“对！”小Hi满意于小Ho的上道，继续说道：“然后我放开限制，我允许MinDistance(i, j)——从第i个点到第j个点的最短路径的长度，拥有的<strong>限制，变为：这条路径仅允许经过1号节点。</strong>”</p><p>“这个也简单，<strong>对于两个节点i, j，我只需要比较MinDistance(i, j)原来的值和MinDistance(i, 1)+MinDistance(1, j)的值，取较小的一个作为新的MinDistance(i, j)</strong>就可以了——毕竟原来的MinDistance都是不经过任何节点，那么这样求出来的新的MinDistance(i, j)只有可能经过1号节点。”</p><p>“那么接下来就是关键的了，我<strong>将限制继续放宽——路径仅允许经过1、2号节点</strong>。”小Hi继续说道。</p><p>“那其实也没有任何变化吧，<strong>对于两个节点i, j，我只需要比较MinDistance(i, j)原来的值和MinDistance(i, 2)+MinDistance(2, j)的值，取较小的一个作为新的MinDistance(i, j)</strong>，之所以可以这样是因为，<strong>原来的MinDistance都是在限制“仅允许经过1号节点”下，求出来的，所以新求出来的MinDistance(i, j)也只有可能经过1、2号节点！</strong>“</p><p>“那我继续放开限制呢？”小Hi问道。</p><p>“也没有什么区别了，<strong>每放开一个新的节点k允许作为路径中的节点，就对于任意的i, j，用MinDistance(i, k)+MinDistance(k, j)去更新MinDistance(i, j)，直到1..N号节点都被添加进限制，此时也就等于没有限制了，那么这个时候的MinDistance(i, j)就是我们所想要求的值，写成伪代码就是这样！”</strong>
</p><p>“看来你已经很明白了呢！”小Hi嘿嘿一笑，往鬼屋深处跑了去——那么接下来就是小Ho利用求出的最短路径，去找到小Hi的时候了！</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为2个整数N、M，分别表示鬼屋中地点的个数和道路的条数。</p><p>接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。

</p><p>对于100%的数据，满足N&lt;=10^2，M&lt;=10^3, 1 &lt;= length_i &lt;= 10^3。</p><p>对于100%的数据，满足迷宫中任意两个地点都可以互相到达。</p><p>对于每组测试数据，输出一个N*N的矩阵A，其中第i行第j列表示，从第i个地点到达第j个地点的最短路径的长度，当i=j时这个距离应当为0。</p><p>万圣节的中午，小Hi和小Ho在吃过中饭之后，来到了一个新的鬼屋！</p><p>鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，但是并不存在一条两端都是同一个地点的道路。</p><p>由于没有肚子的压迫，小Hi和小Ho决定好好的逛一逛这个鬼屋，逛着逛着，小Hi产生了这样的问题：鬼屋中任意两个地点之间的最短路径是多少呢？</p><p>小Ho道：“你说的很有道理，我只需要从每个节点开始使用Dijstra算法就可以了！”</p><p>小Hi摇摇头道：“解决问题不是关键，学到知识才是关键，而且知识本身也远远没有掌握学习的方法重要！”</p><p>小Ho只得答道：“好的好的，听你说便是了!”</p><p>于是小Hi便开心道：“这次要说的算法叫做Floyd算法，是一种用于求图结构上任意两点间最短距离的算法！”</p><p>小Ho嘀咕道：“你都写标题上了，能不知道么？”</p><p>小Hi强行装作没听到，继续说道：“这个算法的核心之处在于数学归纳法——<strong>MinDistance(i, j)之间最短路径中可以用到的节点是一点点增加的！</strong>”</p><p>“你这话每一个字我都听得懂，但是这句话为什么我听不懂呢……”小Ho无奈道。</p><p>“那我这么说吧，<strong>首先，最开始的时候，MinDistance(i, j)——即从第i个点到第j个点的最短路径的长度，拥有一个限制：这条路径不能经过任何节点。</strong>”小Hi道。</p><p>“<strong>那就是说如果从i个点到第j个点之间没有直接相连的边的话，这个长度就是无穷大咯？</strong>”小Ho总结道：“只需要把输入的边填进MinDistance中即可！”</p><p>“对！”小Hi满意于小Ho的上道，继续说道：“然后我放开限制，我允许MinDistance(i, j)——从第i个点到第j个点的最短路径的长度，拥有的<strong>限制，变为：这条路径仅允许经过1号节点。</strong>”</p><p>“这个也简单，<strong>对于两个节点i, j，我只需要比较MinDistance(i, j)原来的值和MinDistance(i, 1)+MinDistance(1, j)的值，取较小的一个作为新的MinDistance(i, j)</strong>就可以了——毕竟原来的MinDistance都是不经过任何节点，那么这样求出来的新的MinDistance(i, j)只有可能经过1号节点。”</p><p>“那么接下来就是关键的了，我<strong>将限制继续放宽——路径仅允许经过1、2号节点</strong>。”小Hi继续说道。</p><p>“那其实也没有任何变化吧，<strong>对于两个节点i, j，我只需要比较MinDistance(i, j)原来的值和MinDistance(i, 2)+MinDistance(2, j)的值，取较小的一个作为新的MinDistance(i, j)</strong>，之所以可以这样是因为，<strong>原来的MinDistance都是在限制“仅允许经过1号节点”下，求出来的，所以新求出来的MinDistance(i, j)也只有可能经过1、2号节点！</strong>“</p><p>“那我继续放开限制呢？”小Hi问道。</p><p>“也没有什么区别了，<strong>每放开一个新的节点k允许作为路径中的节点，就对于任意的i, j，用MinDistance(i, k)+MinDistance(k, j)去更新MinDistance(i, j)，直到1..N号节点都被添加进限制，此时也就等于没有限制了，那么这个时候的MinDistance(i, j)就是我们所想要求的值，写成伪代码就是这样！”</strong>
</p><p>“看来你已经很明白了呢！”小Hi嘿嘿一笑，往鬼屋深处跑了去——那么接下来就是小Ho利用求出的最短路径，去找到小Hi的时候了！</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为2个整数N、M，分别表示鬼屋中地点的个数和道路的条数。</p><p>接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。

</p><p>对于100%的数据，满足N&lt;=10^2，M&lt;=10^3, 1 &lt;= length_i &lt;= 10^3。</p><p>对于100%的数据，满足迷宫中任意两个地点都可以互相到达。</p><p>对于每组测试数据，输出一个N*N的矩阵A，其中第i行第j列表示，从第i个地点到达第j个地点的最短路径的长度，当i=j时这个距离应当为0。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>