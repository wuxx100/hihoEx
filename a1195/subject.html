<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1195</p>p#1195 : 高斯消元·一</p><p> input: </p><dd>
<pre>2 2
2 1 5
1 2 4</pre>
</dd><p> output: </p><dd>
<pre>2
1</pre>
</dd><p>小Ho：喂不得了啦，那边便利店的薯片半价了!</p><p>小Hi：啥?!</p><p>小Ho：那边的便利店在打折促销啊。</p><p>小Hi：走走走，赶紧去看看=v=</p><p>于是小Hi和小Ho来到了便利店。</p><p>老板为了促销，推出了组合包的形式，将不同数量的各类商品打包成一个组合，顾客可以选择组合进行购买。比如2袋薯片，1听可乐的组合只要5元，而1袋薯片，2听可乐的组合只要4元。</p><p>通过询问老板，小Hi和小Ho知道：一共有N种不同的商品和M种不同的商品组合；每一个组合的价格等于组合内商品售价之和，一个组合内同一件商品不会超过10件。</p><p>小Hi：这样算下来的话，一听可乐就是1元，而一包薯片是2元。小Ho，如果你知道所有的组合情况，你能分别算出每一件商品单独的价格么？</p><p>小Ho：当然可以了，这样的小问题怎么能难到我呢？</p><p><a data-target="#m2" data-toggle="modal" href="#">提示：高斯消元</a></p><p>小Ho：&lt;吧唧&gt;&lt;吧唧&gt;&lt;吧唧&gt; </p><p>小Hi：小Ho，你还吃呢。想好了么?</p><p>小Ho：肿抢着呢(正想着呢)...&lt;吞咽&gt;...我记得这个问题上课有提到过，应该是一元一次方程组吧。</p><p>我们把每一件商品的价格看作是x[1]..x[n]，第i个组合中第j件商品数量记为a[i][j]，其价格记作y[i]，则可以列出方程式：</p><p>我们可以对方程组进行3种操作而不改变方程组的解集：</p><p>1. 交换两行。</p><p>2. 把第i行乘以一个非0系数k。即对于j = 1..n， 令a[i][j] = k*a[i][j], y[i]=k*y[i]</p><p>3. 把第p行乘以一个非0系数k之后加在第i行上。即对于j=1..n， 令a[i][j] = a[i][j]+k*a[p][j]，y[i]=y[i]+k*p[i]</p><p>以上三个操作叫做初等行变换。</p><p>我们可以使用它们，对这个方程组中的a[i][j]进行加减乘除变换，举个例子：</p><p>我们可以通过 式子(1) - 式子(2) * (a[1][1] / a[2][1])，将第1行第1列的a[1][1]变换为0。</p><p>对整个方程组进行多次变换之后，可以使得a[i][j]满足：</p><p>则整个方程组变成了：</p><p>这样的话，y'[1] .. y'[n]就是我们要求的x[1]..x[n]</p><p>小Hi：挺不错的嘛，继续？</p><p>小Ho：好，关于如何变换，我们可以利用一个叫<a href="https://en.wikipedia.org/wiki/Gaussian_elimination">高斯消元</a>的算法。高斯消元分成了2个步骤：</p><p>首先我们要计算出<strong>上三角矩阵</strong>，也就是将方程组变为：</p><p>也就是通过变换，将所有a[i][j](i&gt;j)变换为0。同时要保证对角线上的元素a[i][i]不为0。</p><p>方法也很见简单，从第1行开始，我们利用当前行第i列不为0，就可以通过变换将i+1..M行第一列全部变换为0，接着对于第2行，我们用同样的方法将第3..M行第2列也变换为0...不断重复直到第n行为止。</p><p>假如计算到第i行时，第i列已经为0，则我们需要在第i+1..M行中找到一行第i列不为0的行k，并交换第i行和第k行，来保证a[i][i] != 0。但这时候还有可能出现一个情况，就是第i..M行中的i列均为0，此时可以判定，该方程组有多解。</p><p><br/></p><p>当得到上三角矩阵后，就可以从第n行开始逆推，一步一步将a[i][j](i&lt;j)也变换为0.</p><p>因为第n行为a[n][n] * x[n] = y'[n]，则x[n] = y'[n] / a[n][n]。</p><p>第n-1行为a[n-1][n-1] * x[n - 1] + a[n][n] * x[n] = y'[n - 1]。我们将得到的x[n]代入，即可计算出x[n-1]。</p><p>同样的依次类推就可以得到所有的x[1]..x[n]。</p><p><br/></p><p>而对于多解和无解的判定：</p><p>当在求出的上三角矩阵中出现了 a[i][1] = a[i][2] = ... = a[i][n] = 0, 但是y'[i] != 0时，产生了矛盾，即出现了无解的情况。</p><p>而多解的证明如下：</p><p>假设n=3,m=3，而我们计算出了上三角矩阵为：</p><p>当我们在第一个式子中消去x[3]后，有a * x[1] + b * x[2] = g，显然x[1]和x[2]有无穷多种可能的取值。</p><p>小Hi：既然小Ho你都已经把整个算法讲了，那么我就只能给出伪代码了：</p><p>那最后能够拜托你实现一下这个算法么？</p><p>小Ho：没问题，等我吃完这包薯片就去！</p><p><br/></p><p>第1行：2个正整数，N,M。表示商品的数量N，组合的数量M。1≤N≤500, N≤M≤2*N</p><p>第2..M+1行：N+1个非负整数，第i+1行第j列表示在第i个组合中，商品j的数量a[i][j]。第i+1行第N+1个数表示该组合的售价c[i]。0≤a[i][j]≤10, 0≤c[i]≤10^9</p><p>若没有办法计算出每个商品单独的价格，输出"No solutions"。</p><p>若可能存在多个不同的结果，输出"Many solutions"。</p><p>若存在唯一可能的结果，输出N行，每行一个非负整数，第i行表示第i个商品单独的售价。数据保证如果存在唯一解，那么解一定恰好是非负整数解。</p><p>小Ho：喂不得了啦，那边便利店的薯片半价了!</p><p>小Hi：啥?!</p><p>小Ho：那边的便利店在打折促销啊。</p><p>小Hi：走走走，赶紧去看看=v=</p><p>于是小Hi和小Ho来到了便利店。</p><p>老板为了促销，推出了组合包的形式，将不同数量的各类商品打包成一个组合，顾客可以选择组合进行购买。比如2袋薯片，1听可乐的组合只要5元，而1袋薯片，2听可乐的组合只要4元。</p><p>通过询问老板，小Hi和小Ho知道：一共有N种不同的商品和M种不同的商品组合；每一个组合的价格等于组合内商品售价之和，一个组合内同一件商品不会超过10件。</p><p>小Hi：这样算下来的话，一听可乐就是1元，而一包薯片是2元。小Ho，如果你知道所有的组合情况，你能分别算出每一件商品单独的价格么？</p><p>小Ho：当然可以了，这样的小问题怎么能难到我呢？</p><p><a data-target="#m2" data-toggle="modal" href="#">提示：高斯消元</a></p><p>小Ho：&lt;吧唧&gt;&lt;吧唧&gt;&lt;吧唧&gt; </p><p>小Hi：小Ho，你还吃呢。想好了么?</p><p>小Ho：肿抢着呢(正想着呢)...&lt;吞咽&gt;...我记得这个问题上课有提到过，应该是一元一次方程组吧。</p><p>我们把每一件商品的价格看作是x[1]..x[n]，第i个组合中第j件商品数量记为a[i][j]，其价格记作y[i]，则可以列出方程式：</p><p>我们可以对方程组进行3种操作而不改变方程组的解集：</p><p>1. 交换两行。</p><p>2. 把第i行乘以一个非0系数k。即对于j = 1..n， 令a[i][j] = k*a[i][j], y[i]=k*y[i]</p><p>3. 把第p行乘以一个非0系数k之后加在第i行上。即对于j=1..n， 令a[i][j] = a[i][j]+k*a[p][j]，y[i]=y[i]+k*p[i]</p><p>以上三个操作叫做初等行变换。</p><p>我们可以使用它们，对这个方程组中的a[i][j]进行加减乘除变换，举个例子：</p><p>我们可以通过 式子(1) - 式子(2) * (a[1][1] / a[2][1])，将第1行第1列的a[1][1]变换为0。</p><p>对整个方程组进行多次变换之后，可以使得a[i][j]满足：</p><p>则整个方程组变成了：</p><p>这样的话，y'[1] .. y'[n]就是我们要求的x[1]..x[n]</p><p>小Hi：挺不错的嘛，继续？</p><p>小Ho：好，关于如何变换，我们可以利用一个叫<a href="https://en.wikipedia.org/wiki/Gaussian_elimination">高斯消元</a>的算法。高斯消元分成了2个步骤：</p><p>首先我们要计算出<strong>上三角矩阵</strong>，也就是将方程组变为：</p><p>也就是通过变换，将所有a[i][j](i&gt;j)变换为0。同时要保证对角线上的元素a[i][i]不为0。</p><p>方法也很见简单，从第1行开始，我们利用当前行第i列不为0，就可以通过变换将i+1..M行第一列全部变换为0，接着对于第2行，我们用同样的方法将第3..M行第2列也变换为0...不断重复直到第n行为止。</p><p>假如计算到第i行时，第i列已经为0，则我们需要在第i+1..M行中找到一行第i列不为0的行k，并交换第i行和第k行，来保证a[i][i] != 0。但这时候还有可能出现一个情况，就是第i..M行中的i列均为0，此时可以判定，该方程组有多解。</p><p><br/></p><p>当得到上三角矩阵后，就可以从第n行开始逆推，一步一步将a[i][j](i&lt;j)也变换为0.</p><p>因为第n行为a[n][n] * x[n] = y'[n]，则x[n] = y'[n] / a[n][n]。</p><p>第n-1行为a[n-1][n-1] * x[n - 1] + a[n][n] * x[n] = y'[n - 1]。我们将得到的x[n]代入，即可计算出x[n-1]。</p><p>同样的依次类推就可以得到所有的x[1]..x[n]。</p><p><br/></p><p>而对于多解和无解的判定：</p><p>当在求出的上三角矩阵中出现了 a[i][1] = a[i][2] = ... = a[i][n] = 0, 但是y'[i] != 0时，产生了矛盾，即出现了无解的情况。</p><p>而多解的证明如下：</p><p>假设n=3,m=3，而我们计算出了上三角矩阵为：</p><p>当我们在第一个式子中消去x[3]后，有a * x[1] + b * x[2] = g，显然x[1]和x[2]有无穷多种可能的取值。</p><p>小Hi：既然小Ho你都已经把整个算法讲了，那么我就只能给出伪代码了：</p><p>那最后能够拜托你实现一下这个算法么？</p><p>小Ho：没问题，等我吃完这包薯片就去！</p><p><br/></p><p>第1行：2个正整数，N,M。表示商品的数量N，组合的数量M。1≤N≤500, N≤M≤2*N</p><p>第2..M+1行：N+1个非负整数，第i+1行第j列表示在第i个组合中，商品j的数量a[i][j]。第i+1行第N+1个数表示该组合的售价c[i]。0≤a[i][j]≤10, 0≤c[i]≤10^9</p><p>若没有办法计算出每个商品单独的价格，输出"No solutions"。</p><p>若可能存在多个不同的结果，输出"Many solutions"。</p><p>若存在唯一可能的结果，输出N行，每行一个非负整数，第i行表示第i个商品单独的售价。数据保证如果存在唯一解，那么解一定恰好是非负整数解。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>