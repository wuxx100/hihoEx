<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1081</p>p#1081 : 最短路径·一</p><p> input: </p><dd>
<pre>5 23 5 4
1 2 708
2 3 112
3 4 721
4 5 339
5 4 960
1 5 849
2 5 98
1 4 99
2 4 25
2 1 200
3 1 146
3 2 106
1 4 860
4 1 795
5 4 479
5 4 280
3 4 341
1 4 622
4 2 362
2 3 415
4 1 904
2 1 716
2 5 575
</pre>
</dd><p> output: </p><dd>
<pre>123</pre>
</dd><p>万圣节的早上，小Hi和小Ho在经历了一个小时的争论后，终于决定了如何度过这样有意义的一天——他们决定去闯鬼屋！</p><p>在鬼屋门口排上了若干小时的队伍之后，刚刚进入鬼屋的小Hi和小Ho都颇饥饿，于是他们决定利用进门前领到的地图，找到一条通往终点的最短路径。</p><p>鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，但是并不存在一条两端都是同一个地点的道路。那么小Hi和小Ho至少要走多少路程才能够走出鬼屋去吃东西呢？</p><p>小Ho想了想说道：“唔……我觉得动态规划可以做，但是我找不到计算的顺序，如果我用f[i]表示从S到达编号为i的节点的最短距离的话，我并不能够知道f[1]..f[N]的计算顺序。”</p><p>“所以这个问题不需要那么复杂的算法啦，我就稍微讲讲你就知道了！”小Hi道：“路的长度不可能为负数对不对？”</p><p>“那是自然，毕竟人类还没有发明时光机器……”小Ho点点头。</p><p>于是小Hi问道：“那么如果就看与S相邻的所有节点中与S最近的那一个S'，并且从S到S'的距离为L，那么有可能存在另外的道路使得从S到S'的距离小于L么？”</p><p>“不能，因为S'是与S相邻的所有节点中与S最近的节点，那么从S到其他相邻点的距离一定是不小于L的，也就是说无论接下来怎么走，回到L点时总距离一定大于L。”小Ho思考了一会，道。</p><p>“也就是说你已经知道了从S到S'的最短路径了是么？”小Hi继续问道。</p><p>“是的，这条最短路径的长度是L。”小Ho答道。</p><p>小Hi继续道：“那么现在，我们不妨将S同S'看做一个新的节点？称作S1，然后我就计算与S相邻或者与S'相邻的所有节点中，与S最近的哪一个节点S''。注意，在这个过程中，与S相邻的节点与S的距离在上一步就已经求出来了，那么我要求的只有与S'相邻的那些节点与S的距离——这个距离等于S与S'的距离加上S'与这些结点的距离，对于其中重复的节点——同时与S和S'相邻的节点，取两条路径中的较小值。”</p><p>小Ho点了点头：“那么同之前一样，与S1（即S与S'节点）相邻的节点中与S'距离最近的节点如果是S''的话，并且这个距离是L2，那么我们可以知道S到S''的最短路径的长度便是L2，因为不可能存在另外的道路比这个更短了。”</p><p>于是小Hi总结道：“接下来的问题不就很简单了么，只需要以此类推，每次将与当前集合相邻（即与当前集合中任意一个元素）的所有节点中离S最近的节点（这些距离可以通过上一次的计算结果推导而出）选出来添加到当前集合中，我就能够保证在每一个节点被添加到集合中时所计算的离S的距离是它与S之间的最短路径！”</p><p>“原来是这样！但是我的肚子更饿了呢！”言罢，小Ho的肚子咕咕叫了起来。</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。</p><p>接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。

</p><p>对于100%的数据，满足N&lt;=10^3，M&lt;=10^4, 1 &lt;= length_i &lt;= 10^3, 1 &lt;= S, T &lt;= N, 且S不等于T。</p><p>对于100%的数据，满足小Hi和小Ho总是有办法从入口通过地图上标注出来的道路到达出口。</p><p>对于每组测试数据，输出一个整数Ans，表示那么小Hi和小Ho为了走出鬼屋至少要走的路程。</p><p>万圣节的早上，小Hi和小Ho在经历了一个小时的争论后，终于决定了如何度过这样有意义的一天——他们决定去闯鬼屋！</p><p>在鬼屋门口排上了若干小时的队伍之后，刚刚进入鬼屋的小Hi和小Ho都颇饥饿，于是他们决定利用进门前领到的地图，找到一条通往终点的最短路径。</p><p>鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，但是并不存在一条两端都是同一个地点的道路。那么小Hi和小Ho至少要走多少路程才能够走出鬼屋去吃东西呢？</p><p>小Ho想了想说道：“唔……我觉得动态规划可以做，但是我找不到计算的顺序，如果我用f[i]表示从S到达编号为i的节点的最短距离的话，我并不能够知道f[1]..f[N]的计算顺序。”</p><p>“所以这个问题不需要那么复杂的算法啦，我就稍微讲讲你就知道了！”小Hi道：“路的长度不可能为负数对不对？”</p><p>“那是自然，毕竟人类还没有发明时光机器……”小Ho点点头。</p><p>于是小Hi问道：“那么如果就看与S相邻的所有节点中与S最近的那一个S'，并且从S到S'的距离为L，那么有可能存在另外的道路使得从S到S'的距离小于L么？”</p><p>“不能，因为S'是与S相邻的所有节点中与S最近的节点，那么从S到其他相邻点的距离一定是不小于L的，也就是说无论接下来怎么走，回到L点时总距离一定大于L。”小Ho思考了一会，道。</p><p>“也就是说你已经知道了从S到S'的最短路径了是么？”小Hi继续问道。</p><p>“是的，这条最短路径的长度是L。”小Ho答道。</p><p>小Hi继续道：“那么现在，我们不妨将S同S'看做一个新的节点？称作S1，然后我就计算与S相邻或者与S'相邻的所有节点中，与S最近的哪一个节点S''。注意，在这个过程中，与S相邻的节点与S的距离在上一步就已经求出来了，那么我要求的只有与S'相邻的那些节点与S的距离——这个距离等于S与S'的距离加上S'与这些结点的距离，对于其中重复的节点——同时与S和S'相邻的节点，取两条路径中的较小值。”</p><p>小Ho点了点头：“那么同之前一样，与S1（即S与S'节点）相邻的节点中与S'距离最近的节点如果是S''的话，并且这个距离是L2，那么我们可以知道S到S''的最短路径的长度便是L2，因为不可能存在另外的道路比这个更短了。”</p><p>于是小Hi总结道：“接下来的问题不就很简单了么，只需要以此类推，每次将与当前集合相邻（即与当前集合中任意一个元素）的所有节点中离S最近的节点（这些距离可以通过上一次的计算结果推导而出）选出来添加到当前集合中，我就能够保证在每一个节点被添加到集合中时所计算的离S的距离是它与S之间的最短路径！”</p><p>“原来是这样！但是我的肚子更饿了呢！”言罢，小Ho的肚子咕咕叫了起来。</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。</p><p>接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。

</p><p>对于100%的数据，满足N&lt;=10^3，M&lt;=10^4, 1 &lt;= length_i &lt;= 10^3, 1 &lt;= S, T &lt;= N, 且S不等于T。</p><p>对于100%的数据，满足小Hi和小Ho总是有办法从入口通过地图上标注出来的道路到达出口。</p><p>对于每组测试数据，输出一个整数Ans，表示那么小Hi和小Ho为了走出鬼屋至少要走的路程。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>