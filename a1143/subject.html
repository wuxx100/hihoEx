<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1143</p>p#1143 : 骨牌覆盖问题·一</p><p> input: </p><dd>
<pre>62247088</pre>
</dd><p> output: </p><dd>
<pre>17748018</pre>
</dd><p>
骨牌，一种古老的玩具。今天我们要研究的是骨牌的覆盖问题：<br/>
我们有一个2xN的长条形棋盘，然后用1x2的骨牌去覆盖整个棋盘。对于这个棋盘，一共有多少种不同的覆盖方法呢？<br/>
举个例子，对于长度为1到3的棋盘，我们有下面几种覆盖方式：
</p><p><img src="http://media.hihocoder.com/problem_images/20150411/1428731713269.png" style="width:50%;" title="week41_1.PNG"/></p><p><a data-target="#m2" data-toggle="modal" href="#">提示：骨牌覆盖</a></p><p>
我们考虑在已经放置了部分骨牌(灰色)的情况下，下一步可以如何放置新的骨牌(蓝色)：
</p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317132756.png" style="width:100%;margin:10px 0;" title="week41_1_2.PNG"/></p><p><a data-target="#power" data-toggle="modal" href="#">提示：如何快速计算结果</a></p><p>
当N很小的时候，我们直接通过递推公式便可以计算。当N很大的时候，只要我们的电脑足够好，我们仍然可以直接通过递推公式来计算。<br/>
但是我们学算法的，总是这样直接枚举不是显得很Low么，所以我们要用一个好的算法来加速(装X)。<br/>
事实上，对于这种线性递推式，我们可以用<a href="http://en.wikipedia.org/wiki/Matrix_multiplication" target="_blank">矩阵乘法</a>来求第n项。对于本题Fibonacci数列，我们希望找到一个2x2的矩阵M，使得(a, b) x M = (b, a+b)，其中(a, b)和(b, a+b)都是1x2的矩阵。<br/>
显然，只需要取M = [0, 1; 1, 1]就可以了：
</p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317138007.png" style="width:50%;margin:10px 0;" title="week41_2.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317149859.png" style="width:50%;margin:10px 0;" title="week41_3.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317146582.png" style="width:50%;margin:10px 0;" title="week41_4_1.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/1428731714116.png" style="width:100%;margin:10px 0;" title="week41_4.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317144552.png" style="width:30%;margin:10px 0;" title="week41_5.PNG"/></p><p>第1行：1个整数N。表示棋盘长度。1≤N≤100,000,000</p><p>第1行：1个整数，表示覆盖方案数 MOD 19999997</p><p>
骨牌，一种古老的玩具。今天我们要研究的是骨牌的覆盖问题：<br/>
我们有一个2xN的长条形棋盘，然后用1x2的骨牌去覆盖整个棋盘。对于这个棋盘，一共有多少种不同的覆盖方法呢？<br/>
举个例子，对于长度为1到3的棋盘，我们有下面几种覆盖方式：
</p><p><img src="http://media.hihocoder.com/problem_images/20150411/1428731713269.png" style="width:50%;" title="week41_1.PNG"/></p><p><a data-target="#m2" data-toggle="modal" href="#">提示：骨牌覆盖</a></p><p>
我们考虑在已经放置了部分骨牌(灰色)的情况下，下一步可以如何放置新的骨牌(蓝色)：
</p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317132756.png" style="width:100%;margin:10px 0;" title="week41_1_2.PNG"/></p><p><a data-target="#power" data-toggle="modal" href="#">提示：如何快速计算结果</a></p><p>
当N很小的时候，我们直接通过递推公式便可以计算。当N很大的时候，只要我们的电脑足够好，我们仍然可以直接通过递推公式来计算。<br/>
但是我们学算法的，总是这样直接枚举不是显得很Low么，所以我们要用一个好的算法来加速(装X)。<br/>
事实上，对于这种线性递推式，我们可以用<a href="http://en.wikipedia.org/wiki/Matrix_multiplication" target="_blank">矩阵乘法</a>来求第n项。对于本题Fibonacci数列，我们希望找到一个2x2的矩阵M，使得(a, b) x M = (b, a+b)，其中(a, b)和(b, a+b)都是1x2的矩阵。<br/>
显然，只需要取M = [0, 1; 1, 1]就可以了：
</p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317138007.png" style="width:50%;margin:10px 0;" title="week41_2.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317149859.png" style="width:50%;margin:10px 0;" title="week41_3.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317146582.png" style="width:50%;margin:10px 0;" title="week41_4_1.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/1428731714116.png" style="width:100%;margin:10px 0;" title="week41_4.PNG"/></p><p><img src="http://media.hihocoder.com/problem_images/20150411/14287317144552.png" style="width:30%;margin:10px 0;" title="week41_5.PNG"/></p><p>第1行：1个整数N。表示棋盘长度。1≤N≤100,000,000</p><p>第1行：1个整数，表示覆盖方案数 MOD 19999997</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>