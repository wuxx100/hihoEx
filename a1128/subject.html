<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1128</p>p#1128 : 二分·二分查找</p><p> input: </p><dd>
<pre>10 5180
2970 663 5480 4192 4949 1 1387 4428 5180 2761</pre>
</dd><p> output: </p><dd>
<pre>9</pre>
</dd><p>Nettle最近在玩《艦これ》，因此Nettle收集了很多很多的船(这里我们假设Nettle氪了很多金，开了无数个船位)。去除掉重复的船之后，还剩下N(1≤N≤1,000,000)种不同的船。<strong>每一艘船有一个稀有值，任意两艘船的稀有值都不相同，</strong>稀有值越小的船越稀有，价值也就越高。<br/>
Nettle现在通过大建又造出了一艘船，他想知道这艘船是不是重复的。如果是重复的，那么这艘船在Nettle所有的船里面稀有值排多少位。</p><p>
</p><p><a data-target="#m1" data-toggle="modal" href="#">提示一：有序数组的二分查找</a></p><p>
有序数组长度为N，且满足a[1]&amp;lta[2]&amp;lt…&amp;lta[N]。<br/>
我们随机从数组中选取一个数a[i]，对于需要查找的数K：
</p><p>
利用上面这个性质，我们可以得到这样一个算法：<br/>
假定K所在的区间为[L,R]，即a[L]≤K≤a[R]。每次我们从[L,R]中选取一个数Mid，一般情况下选择Mid=(L+R)/2。
</p><p>
这便是最简单，最基本的二分查找。时间复杂度为<strong>O(logN)</strong>
</p><p><a data-target="#m2" data-toggle="modal" href="#">提示二：非有序数组的二分查找</a></p><p>
数组长度为N，保证没有重复的数。<br/>
一个简单有效的方法是对数组进行排序后使用有序数组的二分查找，时间复杂度为O(NlogN)。
</p><p>
观察我们第一个算法，对于选定的Mid。如果数组满足a[L..Mid-1]&amp;lta[Mid]且a[Mid]&amp;lta[Mid+1..R]，即可进行区间的分割，从而使得区间范围减半。<br/>
<strong>既然如此，那么我们可以通过一次遍历交换将比a[Mid]小的数放到a[Mid]左边，比a[Mid]大的数放到a[Mid]右边。(这里使用了快速排序的思想)</strong><br/>
其他部分仍然同有序数组的二分查找相同，但由于每一次都遍历了整个数组，所以时间复杂度变为：O(N/2^0+N/2^1+N/2^2+1)=O(2N)
</p><p>
由于第一个问题很简单，所以我们就拿第二个问题练练手吧。
</p><p>
第1行：2个整数N,K。N表示数组长度，K表示需要查找的数；<br/>
第2行：N个整数，表示a[1..N]，保证不会出现重复的数，1≤a[i]≤2,000,000,000。</p><p>第1行：一个整数t，表示K在数组中是第t小的数，若K不在数组中，输出-1。</p><p>Nettle最近在玩《艦これ》，因此Nettle收集了很多很多的船(这里我们假设Nettle氪了很多金，开了无数个船位)。去除掉重复的船之后，还剩下N(1≤N≤1,000,000)种不同的船。<strong>每一艘船有一个稀有值，任意两艘船的稀有值都不相同，</strong>稀有值越小的船越稀有，价值也就越高。<br/>
Nettle现在通过大建又造出了一艘船，他想知道这艘船是不是重复的。如果是重复的，那么这艘船在Nettle所有的船里面稀有值排多少位。</p><p>
</p><p><a data-target="#m1" data-toggle="modal" href="#">提示一：有序数组的二分查找</a></p><p>
有序数组长度为N，且满足a[1]&amp;lta[2]&amp;lt…&amp;lta[N]。<br/>
我们随机从数组中选取一个数a[i]，对于需要查找的数K：
</p><p>
利用上面这个性质，我们可以得到这样一个算法：<br/>
假定K所在的区间为[L,R]，即a[L]≤K≤a[R]。每次我们从[L,R]中选取一个数Mid，一般情况下选择Mid=(L+R)/2。
</p><p>
这便是最简单，最基本的二分查找。时间复杂度为<strong>O(logN)</strong>
</p><p><a data-target="#m2" data-toggle="modal" href="#">提示二：非有序数组的二分查找</a></p><p>
数组长度为N，保证没有重复的数。<br/>
一个简单有效的方法是对数组进行排序后使用有序数组的二分查找，时间复杂度为O(NlogN)。
</p><p>
观察我们第一个算法，对于选定的Mid。如果数组满足a[L..Mid-1]&amp;lta[Mid]且a[Mid]&amp;lta[Mid+1..R]，即可进行区间的分割，从而使得区间范围减半。<br/>
<strong>既然如此，那么我们可以通过一次遍历交换将比a[Mid]小的数放到a[Mid]左边，比a[Mid]大的数放到a[Mid]右边。(这里使用了快速排序的思想)</strong><br/>
其他部分仍然同有序数组的二分查找相同，但由于每一次都遍历了整个数组，所以时间复杂度变为：O(N/2^0+N/2^1+N/2^2+1)=O(2N)
</p><p>
由于第一个问题很简单，所以我们就拿第二个问题练练手吧。
</p><p>
第1行：2个整数N,K。N表示数组长度，K表示需要查找的数；<br/>
第2行：N个整数，表示a[1..N]，保证不会出现重复的数，1≤a[i]≤2,000,000,000。</p><p>第1行：一个整数t，表示K在数组中是第t小的数，若K不在数组中，输出-1。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>