<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1093</p>p#1093 : 最短路径·三：SPFA算法</p><p> input: </p><dd>
<pre>5 10 3 5
1 2 997
2 3 505
3 4 118
4 5 54
3 5 480
3 4 796
5 2 794
2 5 146
5 4 604
2 5 63
</pre>
</dd><p> output: </p><dd>
<pre>172</pre>
</dd><p>万圣节的晚上，小Hi和小Ho在吃过晚饭之后，来到了一个巨大的鬼屋！</p><p>鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，但是并不存在一条两端都是同一个地点的道路。</p><p>不过这个鬼屋虽然很大，但是其中的道路并不算多，所以小Hi还是希望能够知道从入口到出口的最短距离是多少？</p><p>“唔……地点很多，道路很少，这个鬼屋是一个稀疏图，既然这一点被特地标注出来，那么想来有其作用的咯？”小Ho道。</p><p>“是的，正好有一种最短路径算法，它的时间复杂度只和边的条数有关，所以特别适合用来解决这种边的数量很少的最短路问题！”小Hi点了点头道：“它就是SPFA算法，即Shortest Path Faster Algorithm。”</p><p>“听上去很厉害的样子，但是实际上怎么做的呢？”小Ho问道。</p><p>“你会用宽度优先搜索写这道题么？”小Hi反问道。</p><p>“这个当然会啊，构造一个队列，最开始队列里只有(S, 0)——表示当前处于点S，从点S到达该点的距离为0，然后每次从队首取出一个节点(i, L)——表示当前处于点i，从点S到达该点的距离为L，接下来遍历所有从这个节点出发的边(i, j, l)——表示i和j之间有一条长度为l的边，将(j, L+l)加入到队尾，最后看所有遍历的(T, X)节点中X的最小值就是答案咯~”小Ho对于搜索已经是熟稔于心，张口便道。</p><p>“SPFA算法呢，其实某种意义上就是宽度优先搜索的优化——如果你在尝试将(p, q)加入到队尾的时候，发现队列中已经存在一个(p, q')了，那么你就可以比较q和q'：如果q&gt;=q'，那么(p, q)这个节点实际上是没有继续搜索下去的必要的——算是一种最优化剪枝吧。而如果q&amp;ltq'，那么(p, q')也是没有必要继续搜索下去的——但是它已经存在于队列里了怎么办呢？很简单，将队列中的(p, q')改成(p, q)就可以了！”</p><p>“那我该怎么知道队列中是不是存在一个(p, q')呢？”

</p><p>“所以说这本质上就是宽度优先搜索的剪枝咯？”小Ho问道。</p><p>小Hi笑道：“怎么可能！SPFA算法其实是BELLMAN-FORD算法的一种优化版本，只不过在成型之后可以被理解成为宽度优先搜索的！这个问题，我们会在之后好好讲一讲的！”</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。</p><p>接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。

</p><p>对于100%的数据，满足<strong>N&lt;=10^5，M&lt;=10^6</strong>, 1 &lt;= length_i &lt;= 10^3, 1 &lt;= S, T &lt;= N, 且S不等于T。</p><p>对于100%的数据，满足小Hi和小Ho总是有办法从入口通过地图上标注出来的道路到达出口。</p><p>对于每组测试数据，输出一个整数Ans，表示那么小Hi和小Ho为了走出鬼屋至少要走的路程。</p><p>万圣节的晚上，小Hi和小Ho在吃过晚饭之后，来到了一个巨大的鬼屋！</p><p>鬼屋中一共有N个地点，分别编号为1..N，这N个地点之间互相有一些道路连通，两个地点之间可能有多条道路连通，但是并不存在一条两端都是同一个地点的道路。</p><p>不过这个鬼屋虽然很大，但是其中的道路并不算多，所以小Hi还是希望能够知道从入口到出口的最短距离是多少？</p><p>“唔……地点很多，道路很少，这个鬼屋是一个稀疏图，既然这一点被特地标注出来，那么想来有其作用的咯？”小Ho道。</p><p>“是的，正好有一种最短路径算法，它的时间复杂度只和边的条数有关，所以特别适合用来解决这种边的数量很少的最短路问题！”小Hi点了点头道：“它就是SPFA算法，即Shortest Path Faster Algorithm。”</p><p>“听上去很厉害的样子，但是实际上怎么做的呢？”小Ho问道。</p><p>“你会用宽度优先搜索写这道题么？”小Hi反问道。</p><p>“这个当然会啊，构造一个队列，最开始队列里只有(S, 0)——表示当前处于点S，从点S到达该点的距离为0，然后每次从队首取出一个节点(i, L)——表示当前处于点i，从点S到达该点的距离为L，接下来遍历所有从这个节点出发的边(i, j, l)——表示i和j之间有一条长度为l的边，将(j, L+l)加入到队尾，最后看所有遍历的(T, X)节点中X的最小值就是答案咯~”小Ho对于搜索已经是熟稔于心，张口便道。</p><p>“SPFA算法呢，其实某种意义上就是宽度优先搜索的优化——如果你在尝试将(p, q)加入到队尾的时候，发现队列中已经存在一个(p, q')了，那么你就可以比较q和q'：如果q&gt;=q'，那么(p, q)这个节点实际上是没有继续搜索下去的必要的——算是一种最优化剪枝吧。而如果q&amp;ltq'，那么(p, q')也是没有必要继续搜索下去的——但是它已经存在于队列里了怎么办呢？很简单，将队列中的(p, q')改成(p, q)就可以了！”</p><p>“那我该怎么知道队列中是不是存在一个(p, q')呢？”

</p><p>“所以说这本质上就是宽度优先搜索的剪枝咯？”小Ho问道。</p><p>小Hi笑道：“怎么可能！SPFA算法其实是BELLMAN-FORD算法的一种优化版本，只不过在成型之后可以被理解成为宽度优先搜索的！这个问题，我们会在之后好好讲一讲的！”</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。</p><p>接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。

</p><p>对于100%的数据，满足<strong>N&lt;=10^5，M&lt;=10^6</strong>, 1 &lt;= length_i &lt;= 10^3, 1 &lt;= S, T &lt;= N, 且S不等于T。</p><p>对于100%的数据，满足小Hi和小Ho总是有办法从入口通过地图上标注出来的道路到达出口。</p><p>对于每组测试数据，输出一个整数Ans，表示那么小Hi和小Ho为了走出鬼屋至少要走的路程。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>