<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <p>https://hihocoder.com/problemset/problem/1109</p>p#1109 : 最小生成树三·堆优化的Prim算法</p><p> input: </p><dd>
<pre>5 29
1 2 674
2 3 249
3 4 672
4 5 933
1 2 788
3 4 147
2 4 504
3 4 38
1 3 65
3 5 6
1 5 865
1 3 590
1 4 682
2 4 227
2 4 636
1 4 312
1 3 143
2 5 158
2 3 516
3 5 102
1 5 605
1 4 99
4 5 224
2 4 198
3 5 894
1 5 845
3 4 7
2 4 14
1 4 185
</pre>
</dd><p> output: </p><dd>
<pre>92</pre>
</dd><p>回到两个星期之前，在<a href="http://hihocoder.com/contest/hiho27/problem/1">成功的使用Kruscal算法解决了问题</a>之后，小Ho产生了一个疑问，究竟这样的算法在稀疏图上比Prim优化之处在哪里呢？</p><p>小Hi这时暂时完成了今天的游戏日常，回过头来对小Ho道：“其实主要是Prim算法本身还有很多需要优化的地方，比如用<a href="http://hihocoder.com/contest/hiho28/problem/1">堆</a>就可以很好的解决求最小值部分和合并节点的问题。”。</p><p>小Ho想了想，道：“堆？求最小值的问题……让我想想，每次将1号节点与一个新的节点K合并的时候，等于是将原来节点K相连的边统统改连到1号节点上，也就是1号节点新添加了几条边，在稀疏图的前提下，这样的边数其实不是很多（或者说总和为O(M)级别的），但是在处理的过程中，由于不是针对稀疏图进行的优化，所以就没有很好的处理这一点（因为如果不是稀疏图的话O(N^2)和O(M)其实是一样的），而是每次都在与1号点相连的所有边中选取最短的边……所以说<strong>用堆优化的方法，其实就是用小根堆维护一个与1号节点相连的边的集合，然后每次在其中找出最小的边，而将这条边连接的点加入到1号节点中，其实就是用新加入节点连接出的几条边去更新堆。</strong>”</p><p>小Hi点了点头：“对的，这就是为什么Prim算法在稀疏图上比Kruscal要慢的原因——本身就存在可以优化的地方，那么你不妨思考一下，现在的时间复杂度是怎么样的呢？”</p><p>小Ho道：“Prim算法本身的时间复杂度是O(N^2)的，而在这个算法中，使用了堆来维护所有的边，操作数一共是O(M)级别的，所以复杂度是O(MlogM)的！而Kruscal算法的时间复杂度是O(MlogM + M * Ackermann'(M))，总的说来，是优化到了和Kruscal算法同样级别了呢。”</p><p>“没错！”小Hi笑道。</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为2个整数N、M，表示小Hi拥有的城市数量和小Hi筛选出路线的条数。</p><p>接下来的M行，每行描述一条路线，其中第i行为3个整数N1_i, N2_i, V_i，分别表示这条路线的两个端点和在这条路线上建造道路的费用。</p><p>对于100%的数据，满足N&lt;=10^5, M&lt;=10^6，于任意i满足1&lt;=N1_i, N2_i&lt;=N, N1_i≠N2_i, 1&lt;=V_i&lt;=10^3.</p><p>对于100%的数据，满足一定存在一种方案，使得任意两座城市都可以互相到达。</p><p>对于每组测试数据，输出1个整数Ans，表示为了使任意两座城市都可以通过所建造的道路互相到达至少需要的建造费用。</p><p>回到两个星期之前，在<a href="http://hihocoder.com/contest/hiho27/problem/1">成功的使用Kruscal算法解决了问题</a>之后，小Ho产生了一个疑问，究竟这样的算法在稀疏图上比Prim优化之处在哪里呢？</p><p>小Hi这时暂时完成了今天的游戏日常，回过头来对小Ho道：“其实主要是Prim算法本身还有很多需要优化的地方，比如用<a href="http://hihocoder.com/contest/hiho28/problem/1">堆</a>就可以很好的解决求最小值部分和合并节点的问题。”。</p><p>小Ho想了想，道：“堆？求最小值的问题……让我想想，每次将1号节点与一个新的节点K合并的时候，等于是将原来节点K相连的边统统改连到1号节点上，也就是1号节点新添加了几条边，在稀疏图的前提下，这样的边数其实不是很多（或者说总和为O(M)级别的），但是在处理的过程中，由于不是针对稀疏图进行的优化，所以就没有很好的处理这一点（因为如果不是稀疏图的话O(N^2)和O(M)其实是一样的），而是每次都在与1号点相连的所有边中选取最短的边……所以说<strong>用堆优化的方法，其实就是用小根堆维护一个与1号节点相连的边的集合，然后每次在其中找出最小的边，而将这条边连接的点加入到1号节点中，其实就是用新加入节点连接出的几条边去更新堆。</strong>”</p><p>小Hi点了点头：“对的，这就是为什么Prim算法在稀疏图上比Kruscal要慢的原因——本身就存在可以优化的地方，那么你不妨思考一下，现在的时间复杂度是怎么样的呢？”</p><p>小Ho道：“Prim算法本身的时间复杂度是O(N^2)的，而在这个算法中，使用了堆来维护所有的边，操作数一共是O(M)级别的，所以复杂度是O(MlogM)的！而Kruscal算法的时间复杂度是O(MlogM + M * Ackermann'(M))，总的说来，是优化到了和Kruscal算法同样级别了呢。”</p><p>“没错！”小Hi笑道。</p><p>每个测试点（输入文件）有且仅有一组测试数据。</p><p>在一组测试数据中：</p><p>第1行为2个整数N、M，表示小Hi拥有的城市数量和小Hi筛选出路线的条数。</p><p>接下来的M行，每行描述一条路线，其中第i行为3个整数N1_i, N2_i, V_i，分别表示这条路线的两个端点和在这条路线上建造道路的费用。</p><p>对于100%的数据，满足N&lt;=10^5, M&lt;=10^6，于任意i满足1&lt;=N1_i, N2_i&lt;=N, N1_i≠N2_i, 1&lt;=V_i&lt;=10^3.</p><p>对于100%的数据，满足一定存在一种方案，使得任意两座城市都可以互相到达。</p><p>对于每组测试数据，输出1个整数Ans，表示为了使任意两座城市都可以通过所建造的道路互相到达至少需要的建造费用。</p><p>Lifangting Building, Shanyuan Street, Haidian, Beijing</p><p>© 2017 hihoCoder Hu ICP No.14022864</p>